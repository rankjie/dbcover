// Generated by CoffeeScript 1.6.3
var Q, QueryTable, defaultTTL, logger, prefix, replace_char, sqlbuilder, toType, _;

logger = require('node-simple-logger');

sqlbuilder = require('squel');

_ = require('lodash');

Q = require('q');

toType = require('./utils').toType;

replace_char = '?';

prefix = ':';

defaultTTL = 60;

QueryTable = (function() {
  function QueryTable(table, db, cache, model, nameToField) {
    this.db = db;
    this.cache = cache;
    this.table = table;
    if (model) {
      this.model = model;
    }
    this.nameToField = nameToField;
  }

  QueryTable.prototype.find = function(inputRawSQL, condition) {
    this._inputRawSQL = inputRawSQL;
    this._condition = condition;
    this._queryType = 'find';
    return this;
  };

  QueryTable.prototype.set = function(args) {
    this._args = args;
    return this;
  };

  QueryTable.prototype.orderBy = function(args, order) {
    var _order;
    this._orderBy.push(args);
    _order = order.toUpperCase() === 'DESC' ? false : true;
    this._order.push(_order);
    return this;
  };

  QueryTable.prototype.all = function() {
    return this.list(0, 0);
  };

  QueryTable.prototype.first = function() {
    return this.list(0, 1);
  };

  QueryTable.prototype.list = function(offset, limit) {
    this._offset = offset || 0;
    this._limit = limit;
    return this.query();
  };

  QueryTable.prototype.save = function(obj) {
    var deferred, field, name, _ref;
    this._queryType = 'insert';
    this._cacheData = {};
    this._fieldsToInsert = [];
    deferred = Q.defer();
    _ref = obj.$nameToField;
    for (name in _ref) {
      field = _ref[name];
      this._cacheData[name] = field.toDB(obj[name]);
      field.val = obj[name];
      this._fieldsToInsert.push({
        column: field.column,
        value: field.toDB(obj[name])
      });
    }
    this._cachekey = this.cacheKey(obj);
    this.query().then(function(re) {
      return deferred.resolve(re);
    }, function(err) {
      return deferred.reject(err);
    });
    return deferred.promise;
  };

  QueryTable.prototype.update = function(obj) {
    var field, k, name, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    this._queryType = 'update';
    this._fieldsToUpdate = [];
    this.pkStr = [];
    _ref = obj.$primkeys;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      k = _ref[_i];
      _ref1 = k.keyName;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        name = _ref1[_j];
        this.pkStr.push(obj.$nameToField[name].column + ' = ' + obj.$nameToField[name].val);
      }
    }
    _ref2 = obj.$nameToField;
    for (name in _ref2) {
      field = _ref2[name];
      if (!(obj[name] !== field.val)) {
        continue;
      }
      field.val = obj[name];
      this._fieldsToUpdate.push({
        column: field.column,
        value: field.toDB(obj[name])
      });
    }
    this._cachekey = this.cacheKey(obj);
    this.query().then(function(re) {
      return deferred.resolve(re);
    }, function(err) {
      return deferred.reject(err);
    });
    return deferred.promise;
  };

  QueryTable.prototype["delete"] = function(obj) {
    var k, name, _i, _j, _len, _len1, _ref, _ref1;
    this._queryType = 'delete';
    this.pkStr = [];
    _ref = obj.$primkeys;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      k = _ref[_i];
      _ref1 = k.keyName;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        name = _ref1[_j];
        this.pkStr.push(obj.$nameToField[name].column + ' = ' + obj.$nameToField[name].val);
      }
    }
    this.query().then(function(re) {
      return deferred.resolve(re);
    }, function(err) {
      return deferred.reject(err);
    });
    return deferred.promise;
  };

  QueryTable.prototype.toSQL = function() {
    var columnName, f, field, i, k, name, operator, operators, opkey, sql, str, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    if (this._queryType === 'find') {
      sql = sqlbuilder.select().from(this.table);
      _ref = this.nameToField;
      for (name in _ref) {
        field = _ref[name];
        sql = sql.field(field.column, name);
      }
      if (toType(this._inputRawSQL) === 'string') {
        sql = sql.where(this._inputRawSQL);
      } else if (toType(this._inputRawSQL) === 'object') {
        _ref1 = this._inputRawSQL;
        for (k in _ref1) {
          v = _ref1[k];
          operators = {
            '__gt': ' > ',
            '__lt': ' < '
          };
          opkey = k.slice(k.length - 4, k.length);
          if (opkey !== '__gt' && opkey !== '__lt') {
            operator = ' = ';
            columnName = k;
          } else {
            operator = operators[opkey];
            columnName = k.slice(0, k.length - 4);
          }
          sql = sql.where(this.nameToField[columnName].column + operator + "'" + this.nameToField[columnName].toDB(v) + "'");
        }
      }
      if ((this._orderBy != null) && this._orderBy.length > 0) {
        _ref2 = this._orderBy;
        for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
          f = _ref2[i];
          sql = sql.order(f, this._order[i]);
        }
      }
      if ((this._limit != null) && this._limit !== 0) {
        sql = sql.limit(this._limit);
      }
      if (this._offset != null) {
        sql = sql.offset(this._offset);
      }
    } else if (this._queryType === 'update') {
      sql = sqlbuilder.update().table(this.table);
      _ref3 = this._fieldsToUpdate;
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        f = _ref3[_j];
        sql = sql.set(f.column, f.value);
      }
      _ref4 = this.pkStr;
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        str = _ref4[_k];
        sql = sql.where(str);
      }
    } else if (this._queryType === 'insert') {
      sql = sqlbuilder.insert().into(this.table);
      _ref5 = this._fieldsToInsert;
      for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
        f = _ref5[_l];
        sql = sql.set(f.column, f.value);
      }
    } else if (this._queryType === 'delete') {
      sql = sqlbuilder["delete"]().from(this.table);
      _ref6 = this.pkStr;
      for (_m = 0, _len4 = _ref6.length; _m < _len4; _m++) {
        str = _ref6[_m];
        sql = sql.where(str);
      }
    }
    return sql.toString();
  };

  QueryTable.prototype.query = function() {
    var cacheKey, cacheToInstance, dbToInstance, deferred, instanceToCache, self, sql;
    self = this;
    deferred = Q.defer();
    sql = self.toSQL();
    cacheToInstance = function(data) {
      return dbToInstance(JSON.parse(data));
    };
    instanceToCache = function(obj) {
      return JSON.stringify(obj.$cacheData);
    };
    dbToInstance = function(rows) {
      var field, instances, name, row, _i, _len, _ref;
      instances = [];
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        row = rows[_i];
        _ref = self.nameToField;
        for (name in _ref) {
          field = _ref[name];
          row[name] = field.fromDB(row[name]);
        }
        instances.push(self.model["new"](row));
      }
      return instances;
    };
    if (self._queryType === 'find') {
      cacheKey = sql.replace(/\s+/g, '');
      self.cache.get(cacheKey, function(err, data) {
        var _ref;
        if (err) {
          deferred.reject(err);
        }
        if (_.isEmpty(data) || (data.$family != null)) {
          return self.db.query(sql, (_ref = self._condition) != null ? _ref : self._args, function(err, rows) {
            var obj, _i, _len, _ref1, _results;
            if (err != null) {
              return deferred.reject(err);
            } else {
              self.cache.set(cacheKey, JSON.stringify(rows), defaultTTL, function(err, response) {
                return deferred.resolve(dbToInstance(rows));
              });
              _ref1 = dbToInstance(rows);
              _results = [];
              for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                obj = _ref1[_i];
                _results.push(self.cache.set(self.cacheKey(obj), self.cacheDate(obj), defaultTTL));
              }
              return _results;
            }
          });
        } else {
          return deferred.resolve(cacheToInstance(data[cacheKey]));
        }
      });
    }
    if (self._queryType === 'insert') {
      self.db.query(sql, function(err, rows) {
        if (err) {
          deferred.reject(err);
          return deferred.promise;
        }
        if (self.cache) {
          return self.cache.set(self._cachekey, JSON.stringify(self._cacheData), defaultTTL, function(err, response) {
            if (err != null) {
              deferred.reject(rows);
            }
            return deferred.resolve(rows);
          });
        } else {
          return deferred.resolve(rows);
        }
      });
    }
    if (self._queryType === 'delete') {
      self.db.query(sql, function(err, rows) {
        if (err) {
          deferred.reject(err);
        }
        return self.cache.del(self._cachekey, function(err, numberOfRowsDeleted) {
          if (err) {
            deferred.reject(err);
          }
          return deferred.resolve(numberOfRowsDeleted);
        });
      });
    }
    if (self._queryType === 'update') {
      self.db.query(sql, function(err, rows) {
        if (err) {
          deferred.reject(err);
        }
        return self.cache.del(self._cachekey, function(err, response) {
          if (err) {
            deferred.reject(err);
          }
          return deferred.resolve(null);
        });
      });
    }
    return deferred.promise;
  };

  QueryTable.prototype.cacheKey = function(obj) {
    var k, key, keyname, _i, _j, _len, _len1, _ref, _ref1;
    key = "" + this.table + ":";
    _ref = obj.$primkeys;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      k = _ref[_i];
      _ref1 = k.keyName;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        keyname = _ref1[_j];
        key += obj[keyname] + ':';
      }
    }
    return key.slice(0, -1).replace(/\s+/g, '');
  };

  QueryTable.prototype.cacheDate = function(obj) {
    var field, name, _cacheData, _ref;
    _cacheData = {};
    _ref = obj.$nameToField;
    for (name in _ref) {
      field = _ref[name];
      _cacheData[name] = field.toDB(obj[name]);
    }
    return _cacheData;
  };

  return QueryTable;

})();

module.exports = QueryTable;
