// Generated by CoffeeScript 1.6.3
var Q, QueryTable, defaultTTL, logger, prefix, replace_char, sqlbuilder, toType, _;

logger = require('node-simple-logger');

sqlbuilder = require('squel');

_ = require('lodash');

Q = require('q');

toType = require('./utils').toType;

replace_char = '?';

prefix = ':';

defaultTTL = 60;

QueryTable = (function() {
  function QueryTable(table, db, cache, model, nameToField) {
    this.db = db;
    this.cache = cache;
    this.table = table;
    if (model) {
      this.model = model;
    }
    this.nameToField = nameToField;
  }

  QueryTable.prototype.find = function(inputRawSQL, condition) {
    this._inputRawSQL = inputRawSQL;
    this._condition = condition;
    this._queryType = 'find';
    return this;
  };

  QueryTable.prototype.set = function(args) {
    this._args = args;
    return this;
  };

  QueryTable.prototype.orderBy = function(args, order) {
    var _order;
    this._orderBy.push(args);
    _order = order.toUpperCase() === 'DESC' ? false : true;
    this._order.push(_order);
    return this;
  };

  QueryTable.prototype.first = function() {
    return this.list(0, 1);
  };

  QueryTable.prototype.list = function(offset, limit) {
    this._offset = offset || 0;
    this._limit = limit;
    return this.query();
  };

  QueryTable.prototype.save = function(obj) {
    var field, name, _ref;
    this._queryType = 'insert';
    this._cacheData = {};
    this._fieldsToInsert = [];
    _ref = obj.$nameToField;
    for (name in _ref) {
      field = _ref[name];
      this._cacheData[name] = field.toDB(obj[name]);
      field.val = obj[name];
      this._fieldsToInsert.push({
        column: field.column,
        value: field.toDB(obj[name])
      });
    }
    this._cachekey = this.cacheKey(obj);
    console.log('cacheData: ' + JSON.stringify(this._cacheData));
    console.log('cacheKey: ' + this._cachekey);
    return this.query();
  };

  QueryTable.prototype.update = function(obj) {
    var field, name, _ref;
    this._queryType = 'update';
    this._fieldsToUpdate = [];
    _ref = obj.$nameToField;
    for (name in _ref) {
      field = _ref[name];
      if (!(obj[name] !== field.val)) {
        continue;
      }
      field.val = obj[name];
      this._fieldsToUpdate.push({
        column: field.column,
        value: field.toDB(obj[name])
      });
    }
    this._cachekey = this.cacheKey(obj);
    return this.query();
  };

  QueryTable.prototype["delete"] = function(obj) {
    var k, _i, _len, _ref;
    this._queryType = 'delete';
    this.pkStr = [];
    _ref = obj.$pks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      k = _ref[_i];
      this.pkStr.push(k.fields[0] + ' = ' + obj[k.name]);
    }
    return this.query();
  };

  QueryTable.prototype.toSQL = function() {
    var f, field, i, k, name, sql, str, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    if (this._queryType === 'find') {
      sql = sqlbuilder.select().from(this.table);
      _ref = this.nameToField;
      for (name in _ref) {
        field = _ref[name];
        sql = sql.field(field.column, name);
      }
      if (toType(this._inputRawSQL) === 'string') {
        sql = sql.where(this._inputRawSQL);
      } else if (toType(this._inputRawSQL) === 'object') {
        _ref1 = this._inputRawSQL;
        for (k in _ref1) {
          v = _ref1[k];
          sql = sql.where(this.nameToField[k].column + '=' + this.nameToField[k].toDB(v));
        }
      }
      if ((this._orderBy != null) && this._orderBy.length > 0) {
        _ref2 = this._orderBy;
        for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
          f = _ref2[i];
          sql = sql.order(f, this._order[i]);
        }
      }
      if (this._limit) {
        sql = sql.limit(this._limit);
      }
      if (this._offset) {
        sql = sql.offset(this._offset);
      }
    } else if (this._queryType === 'update') {
      sql = sqlbuilder.update().table(this.table);
      _ref3 = this._fieldsToUpdate;
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        f = _ref3[_j];
        sql = sql.set(f.column, f.value);
      }
    } else if (this._queryType === 'insert') {
      sql = sqlbuilder.insert().into(this.table);
      _ref4 = this._fieldsToInsert;
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        f = _ref4[_k];
        sql = sql.set(f.column, f.value);
      }
    } else if (this._queryType === 'delete') {
      sql = sqlbuilder["delete"]().from(this.table);
      _ref5 = this.pkStr;
      for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
        str = _ref5[_l];
        sql = sql.where(str);
      }
    }
    if (this._condition != null) {
      for (i = _m = 0, _ref6 = sql.match(/\?/g).length; _m < _ref6; i = _m += 1) {
        sql = sql.substr(0, sql.indexOf(replace_char)) + ("" + this._condition[i]) + sql.substr(sql.indexOf(replace_char) + replace_char.length);
      }
    } else if (this._args != null) {
      _ref7 = this._args;
      for (k in _ref7) {
        v = _ref7[k];
        sql = sql.replace(prefix + k, "" + v);
      }
    }
    console.log('最后的查询sql：' + sql.toString());
    return sql.toString();
  };

  QueryTable.prototype.query = function() {
    var cacheToInstance, dbToInstance, deferred, instanceToCache, self, sql;
    self = this;
    deferred = Q.defer();
    sql = self.toSQL();
    cacheToInstance = function(data) {
      return dbToInstance(JSON.parse(data));
    };
    instanceToCache = function(obj) {
      return JSON.stringify(obj.$cacheData);
    };
    dbToInstance = function(rows) {
      var field, instances, name, row, _i, _len, _ref;
      instances = [];
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        row = rows[_i];
        _ref = self.nameToField;
        for (name in _ref) {
          field = _ref[name];
          row[name] = field.fromDB(row[name]);
        }
        instances.push(self.model["new"](row));
      }
      return instances;
    };
    if (self._queryType === 'find') {
      self.cache.get(sql, function(err, data) {
        if (err) {
          deferred.reject(err);
        }
        console.log('cache查到了：');
        if (_.isEmpty(data)) {
          console.log('空的');
        } else {
          console.log(data);
        }
        if (_.isEmpty(data)) {
          console.log('去DB查！');
          return self.db.query(sql, function(err, rows) {
            if (err) {
              deferred.reject(err);
              return deferred.promise;
            }
            return self.cache.set(sql, JSON.stringify(rows), function(err, response) {
              return deferred.resolve(dbToInstance(rows));
            });
          });
        } else {
          return deferred.resolve(cacheToInstance(data[sql]));
        }
      });
    }
    if (self._queryType === 'insert') {
      self.db.query(sql, function(err, rows) {
        if (err) {
          deferred.reject(err);
        }
        if (!self.cache) {
          deferred.resolve(null);
        }
        return self.cache.set(self._cachekey, JSON.stringify(self._cacheData, defaultTTL, function(err, response) {
          if (err) {
            deferred.reject(err);
          }
          return deferred.resolve(null);
        }));
      });
    }
    if (self._queryType === 'delete') {
      self.db.query(sql, function(err, rows) {
        if (err) {
          deferred.reject(err);
        }
        return self.cache.del(self._cachekey, function(err, numberOfRowsDeleted) {
          if (err) {
            deferred.reject(err);
          }
          return deferred.resolve(numberOfRowsDeleted);
        });
      });
    }
    if (self._queryType === 'update') {
      self.db.query(sql, function(err, rows) {
        if (err) {
          deferred.reject(err);
        }
        return self.cache.del(self._cachekey, function(err, response) {
          if (err) {
            deferred.reject(err);
          }
          return deferred.resolve(null);
        });
      });
    }
    return deferred.promise;
  };

  QueryTable.prototype.cacheKey = function(obj) {
    var k, key, _i, _len, _ref;
    key = "" + this.table + ":";
    _ref = obj.$pks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      k = _ref[_i];
      key += obj[k] + ':';
    }
    return key.slice(0, -1);
  };

  return QueryTable;

})();

module.exports = QueryTable;
