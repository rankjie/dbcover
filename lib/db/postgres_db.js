// Generated by CoffeeScript 1.7.1
var Postgres, pg, prefix, replace_char;

pg = require('pg');

replace_char = '?';

prefix = ':';

Postgres = (function() {
  function Postgres(config) {
    this.pool = pg.pools.getOrCreate(config);
  }

  Postgres.prototype.query = function(sql, args, callback) {
    var i, k, replaceAll, v, _i, _ref;
    if (this.debug) {
      console.log('[dbcover]', args);
    }
    replaceAll = function(find, replace, str) {
      return str.replace(new RegExp(find, 'g'), replace);
    };
    if (Object.prototype.toString.call(args) === '[object Array]') {
      for (i = _i = 0, _ref = sql.match(/\?/g).length; _i < _ref; i = _i += 1) {
        sql = sql.substr(0, sql.indexOf(replace_char)) + ("'" + args[i] + "'") + sql.substr(sql.indexOf(replace_char) + replace_char.length);
      }
    } else if (Object.prototype.toString.call(args) === '[object Object]') {
      for (k in args) {
        v = args[k];
        sql = sql.replace(prefix + k, "'" + v + "'");
      }
    }
    sql = replaceAll('`', '"', sql);
    if (callback == null) {
      callback = args;
    }
    if (this.debug) {
      console.log('[dbcover]', sql);
    }
    if (this.debug) {
      console.log('[dbcover]', args);
    }
    return this.pool.connect(function(err, client, done) {
      if (err) {
        return console.error('[dbcover] Error when getting PostgreSQL connection', err);
      }
      return client.query(sql, function(err, rows) {
        var _ref1;
        done();
        return callback(err, (_ref1 = rows['rows']) != null ? _ref1 : rows);
      });
    });
  };

  Postgres.prototype.end = function() {
    return pg.end();
  };

  return Postgres;

})();

module.exports = Postgres;
