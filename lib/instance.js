// Generated by CoffeeScript 2.5.1
var Instance, Q, QueryTable, Validators, _, toType;

({toType} = require('./utils'));

_ = require('lodash');

({Validators} = require('./validators'));

QueryTable = require('./querytable');

Q = require('q');

Instance = class Instance {
  constructor(table, pks, nameToField, vals, db, cache, userDefineMethods, primkeys, ttl) {
    var field, i, len, method, name, ref;
    // console.log arguments
    this.$table = table;
    this.$pks = _.cloneDeep(pks);
    this.$nameToField = _.cloneDeep(nameToField);
    this.$db = db;
    this.$cache = cache;
    this.$primkeys = primkeys;
    this.$ttl = ttl;
    ref = this.$nameToField;
    for (name in ref) {
      field = ref[name];
      // 按照name把键值都存下来，只能透过name访问，不能直接用column来访问
      // 同时也把这个初始值存到field里面，update的时候就能用了
      this[name] = _.cloneDeep(vals[name]);
      field.val = _.cloneDeep(vals[name]);
    }
// 添加用户定义的方法
    for (i = 0, len = userDefineMethods.length; i < len; i++) {
      method = userDefineMethods[i];
      Instance.prototype[method.name] = method.body;
    }
  }

  save() {
    var queryTable, self, validationResult;
    queryTable = new QueryTable(this.$table, this.$db, this.$cache, null, this.$nameToField, this.$ttl);
    validationResult = this.validate();
    self = this;
    if (validationResult.error == null) {
      return queryTable.save(this).then(function(result) {
        return Q(self);
      }, function(err) {
        return Q.reject(err);
      });
    } else {
      return Q.reject(validationResult.error);
    }
  }

  update() {
    var queryTable, validationResult;
    queryTable = new QueryTable(this.$table, this.$db, this.$cache, null, this.$nameToFieldm, this.$ttl);
    validationResult = this.validate();
    if (validationResult.error == null) {
      return queryTable.update(this);
    } else {
      console.log('valid>>>>>>>', validationResult.error);
      return Q.reject(validationResult.error);
    }
  }

  delete() {
    var queryTable;
    queryTable = new QueryTable(this.$table, this.$db, this.$cache, null, this.$nameToField, this.$ttl);
    return queryTable.delete(this);
  }

  // indices(pks)要检查是否为空
  validate() {
    var field, i, index, j, len, len1, name, re, ref, ref1, ref2, result;
    result = {};
    if (this.$pks != null) {
      ref = this.$pks;
      for (i = 0, len = ref.length; i < len; i++) {
        index = ref[i];
        ref1 = index.fields;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          name = ref1[j];
          if (!(this[name] == null)) {
            continue;
          }
          result.error = `Error: Field ${name}: is missing`;
          // Error: ER_DUP_ENTRY: Duplicate entry '999' for key 'PRIMARY'
          return result;
        }
      }
    }
    ref2 = this.$nameToField;
    for (name in ref2) {
      field = ref2[name];
      if ((field.required || field.primkey) && (this[name] == null) && !field.auto) {
        result.error = `Error: Field ${name}: is missing`;
        return result;
      }
      // validator是string的话。例如'email'
      if (field.validator != null) {
        if (toType(field.validator) === 'string') {
          re = new Validators[field.validator].doValidate(this[name]);
        } else {
          re = field.validator.doValidate(this[name]);
        }
        if (re.error) {
          result.error = `Error: Field ${name}: ${re.error}`;
        }
      }
    }
    return result;
  }

  getVals() {
    var field, name, ref, vals;
    vals = {};
    ref = this.$nameToField;
    for (name in ref) {
      field = ref[name];
      vals[name] = this[name];
    }
    return vals;
  }

};

module.exports = Instance;
