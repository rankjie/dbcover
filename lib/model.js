// Generated by CoffeeScript 1.7.1
var EmailValidator, Instance, IntegerValidator, Model, Observe, Q, QueryTable, StringValidator, Validators, cache, cacheGroup, createField, db, defaultTTL, repoGroup, toType, _, _ref;

_ = require('lodash');

toType = require('./utils').toType;

createField = require('./field').createField;

db = require('./db/db');

cache = require('./cache/cache');

Instance = require('./instance');

QueryTable = require('./querytable');

_ref = require('./validators'), Validators = _ref.Validators, StringValidator = _ref.StringValidator, IntegerValidator = _ref.IntegerValidator, EmailValidator = _ref.EmailValidator;

Q = require('q');

repoGroup = {};

cacheGroup = {};

defaultTTL = 60;

Observe = (function() {
  function Observe() {}

  Observe.prototype.define = function(cata, config) {
    if (cata === 'repo') {
      repoGroup[config.name] = db(config.provider);
    }
    if (cata === 'cache') {
      return cacheGroup[config.name] = cache(config.provider);
    }
  };

  Observe.prototype.getRepoAll = function() {
    return repoGroup;
  };

  Observe.prototype.getCacheAll = function() {
    return cacheGroup;
  };

  Observe.prototype.endRepoAll = function() {
    var k, v, _results;
    _results = [];
    for (k in repoGroup) {
      v = repoGroup[k];
      _results.push(v.end());
    }
    return _results;
  };

  Observe.prototype.endCacheAll = function() {
    var k, v, _results;
    _results = [];
    for (k in cacheGroup) {
      v = cacheGroup[k];
      _results.push(v.end());
    }
    return _results;
  };

  Observe.prototype.endAll = function() {
    this.endCacheAll();
    return this.endRepoAll();
  };

  return Observe;

})();

Model = (function() {
  function Model(dataDefine) {
    var body, camelCased, f, k, key, keyName, name, v, _fn, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    this.$indices = dataDefine.meta.indices;
    this.$table = dataDefine.meta.table;
    this.$repo = repoGroup[dataDefine.meta.repo] || repoGroup['default'];
    this.$ttl = (_ref1 = dataDefine.meta.ttl) != null ? _ref1 : defaultTTL;
    this.$cache = false;
    if (dataDefine.meta.cache) {
      this.$cache = cacheGroup[dataDefine.meta.cache] || cacheGroup['default'];
    }
    this.$nameToField = {};
    _ref2 = dataDefine.meta.fields;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      f = _ref2[_i];
      this.$nameToField[f.name] = createField(_.cloneDeep(f));
      _ref3 = Object.getPrototypeOf(this.$nameToField[f.name]);
      for (k in _ref3) {
        v = _ref3[k];
        this.$nameToField[f.name][k] = v;
      }
      if (f.validator) {
        _ref4 = Object.getPrototypeOf(f.validator);
        for (name in _ref4) {
          body = _ref4[name];
          this.$nameToField[f.name].validator[name] = body;
        }
      }
    }
    this.$userDefineMethods = [];
    for (k in dataDefine) {
      v = dataDefine[k];
      if (toType(v) === 'function') {
        Model.prototype[k] = v;
        this.$userDefineMethods.push({
          name: k,
          body: v
        });
      }
    }
    this.primkeys = [];
    _ref5 = dataDefine.meta.fields;
    for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
      f = _ref5[_j];
      if (!(f.primkey != null)) {
        continue;
      }
      key = f.name;
      keyName = [];
      keyName.push(f.name);
      this.primkeys.push({
        name: f.name,
        keyName: keyName
      });
    }
    if (dataDefine.meta.indices != null) {
      _ref6 = dataDefine.meta.indices;
      for (_k = 0, _len2 = _ref6.length; _k < _len2; _k++) {
        f = _ref6[_k];
        if (toType(f.fields) === 'array') {
          keyName = f.fields;
        } else {
          keyName = [];
          keyName.push(index.fields);
        }
        this.primkeys.push({
          name: f.name,
          keyName: keyName
        });
      }
    }
    camelCased = function(str) {
      return str.charAt(0).toUpperCase() + str.slice(1).replace(/(-|_)([a-z])/g, function(s) {
        return s[1].toUpperCase();
      });
    };
    _ref7 = this.primkeys;
    _fn = function(key, self) {
      self['findBy' + camelCased(key.name)] = function(v) {
        var sqlStr, values, _len4, _m, _ref8;
        values = {};
        if (toType(v) !== 'object') {
          values[key.name] = v;
        } else {
          values = v;
        }
        sqlStr = [];
        _ref8 = key.keyName;
        for (_m = 0, _len4 = _ref8.length; _m < _len4; _m++) {
          name = _ref8[_m];
          sqlStr.push(self.$nameToField[name].column + " = '" + self.$nameToField[name].toDB(values[name] + "'"));
        }
        if (self.$nameToField[name].uniq) {
          return self.find(sqlStr.join(' AND ')).first();
        }
        return self.find(sqlStr.join(' AND ')).all();
      };
      return self['findBy' + camelCased(key.name) + 's'] = function(v) {
        var i, promises, _len4, _m;
        promises = [];
        for (_m = 0, _len4 = v.length; _m < _len4; _m++) {
          i = v[_m];
          promises.push(self['findBy' + camelCased(key.name)](i));
        }
        return Q.all(promises).spread(function() {
          var re, result, _len5, _n;
          re = [];
          for (_n = 0, _len5 = arguments.length; _n < _len5; _n++) {
            result = arguments[_n];
            if (toType(result) === 'array') {
              re = re.concat(result);
            }
            if (toType(result) === 'object') {
              re.push(result);
            }
          }
          return Q(re);
        });
      };
    };
    for (_l = 0, _len3 = _ref7.length; _l < _len3; _l++) {
      key = _ref7[_l];
      _fn(key, this);
    }
  }

  Model.prototype["new"] = function(vals) {
    return new Instance(this.$table, this.$indices, this.$nameToField, vals, this.$repo, this.$cache, this.$userDefineMethods, this.primkeys, this.$ttl);
  };

  Model.prototype.find = function(rawSQL, condition) {
    var queryTable;
    queryTable = new QueryTable(this.$table, this.$repo, this.$cache, this, this.$nameToField, this.$ttl);
    return queryTable.find(rawSQL, condition);
  };

  Model.prototype.count = function() {
    var queryTable;
    queryTable = new QueryTable(this.$table, this.$repo, this.$cache, this, this.$nameToField, this.$ttl);
    return queryTable.count();
  };

  return Model;

})();

exports.Model = Model;

exports.Observe = new Observe;

exports.Validators = Validators;
